-- MarI/O by SethBling
-- Feel free to use this code, but please do not redistribute it.
-- Intended for use with the BizHawk emulator and Super Mario World or Super Mario Bros. ROM.
-- For SMW, make sure you have a save state named "DP1.state" at the beginning of a level,
-- and put a copy in both the Lua folder and the root directory of BizHawk.

if gameinfo.getromname() == "Super Mario World (USA)" then
	Filename = "DP1.state"
	ButtonNames = {
		"A",
		"B",
		"X",
		"Y",
		"Up",
		"Down",
		"Left",
		"Right",
	}
end

math.randomseed(os.time()) -- unix timestamp to initialize seed
burn_a_bunch = os.time() + 2 -- try for 2 seconds
if os.time() < burn_a_bunch then
	lots_of_attempts = math.random(1, 1327217884)
end
math.randomseed(lots_of_attempts) -- 

BoxRadius = 6
InputSize = (BoxRadius*2+1)*(BoxRadius*2+1)
Forward_Looking = math.floor(0.8 * 16 * BoxRadius) -- vision tweak
Mario_Map_Offset = math.floor(0.8 * 5 * BoxRadius) -- debug window tweak

Inputs = InputSize+1+4 -- bias cell, plus a few (4) perceptrons
Outputs = #ButtonNames

Nyoom = 0
NyoomCumulator = 0

CurrentSwarm = 0 -- ACTUAL population size
GenerationGain = 73 -- Per-generation soft-target / gain rate
AntiGain = 42 -- Does more than the GenerationGain itself
StaleGatunek = 5 -- Assume unbreedable if the rank stays low (discard rubbish genes)

DeltaDisjoint = 2.0
DeltaWeights = 0.4
DeltaThreshold = 0.437 -- ONLY minor mutations

MutateConnectionsChance = 0.236
PerturbChance = 0.72
CrossoverChance = 0.87
LinkMutationChance = 1.618
NodeMutationChance = 0.618
BiasMutationChance = 1.15
StepSize = 0.1
EnableMutationChance = Inputs * 0.034 -- Try to re-enable 3.4% of dormant genes
DisableMutationChance = Inputs * 0.0236 -- Try to disable 2.36% of active genes
StatusRegister = 0x42 -- not actually 42 in base 10 ... whatever

TimeoutConstant = 97

MaxNodes = 1000000

function getPositions()
	if gameinfo.getromname() == "Super Mario World (USA)" then
		marioX = memory.read_s16_le(0xD1)
		marioY = memory.read_s16_le(0xD3)
		
		local layer1x = memory.read_s16_le(0x1A);
		local layer1y = memory.read_s16_le(0x1C);
		
		screenX = marioX-layer1x
		screenY = marioY-layer1y
	end
end

function getTile(dx, dy)
	if gameinfo.getromname() == "Super Mario World (USA)" then
		x = math.floor((marioX+dx+8)/16)
		y = math.floor((marioY+dy)/16)
		
		return memory.readbyte(0x1C800 + math.floor(x/0x10)*0x1B0 + y*0x10 + x%0x10)
	end
end

function getSprites()
	if gameinfo.getromname() == "Super Mario World (USA)" then
		local sprites = {}
		for slot=0,11 do
			local status = memory.readbyte(0x14C8+slot)
			if status ~= 0 then
				spritex = memory.readbyte(0xE4+slot) + memory.readbyte(0x14E0+slot)*256
				spritey = memory.readbyte(0xD8+slot) + memory.readbyte(0x14D4+slot)*256
				sprites[#sprites+1] = {["x"]=spritex, ["y"]=spritey}
			end
		end		
		
		return sprites
	end
end

function getExtendedSprites()
	if gameinfo.getromname() == "Super Mario World (USA)" then
		local extended = {}
		for slot=0,11 do
			local number = memory.readbyte(0x170B+slot)
			if number ~= 0 then
				spritex = memory.readbyte(0x171F+slot) + memory.readbyte(0x1733+slot)*256
				spritey = memory.readbyte(0x1715+slot) + memory.readbyte(0x1729+slot)*256
				extended[#extended+1] = {["x"]=spritex, ["y"]=spritey}
			end
		end		
		
		return extended
	end
end

function getInputs()
	getPositions()
	
	sprites = getSprites()
	extended = getExtendedSprites()
	
	local inputs = {}
	
	for dy=-BoxRadius*16,BoxRadius*16,16 do
		for dx=-BoxRadius*16,BoxRadius*16,16 do
			XShifted = dx + Forward_Looking
			inputs[#inputs+1] = 0
			
			tile = getTile(XShifted, dy)
			if tile == 1 and marioY+dy < 0x1B0 then
				inputs[#inputs] = 1
			end
			
			for i = 1,#sprites do
				distx = math.abs(sprites[i]["x"] - (marioX+XShifted))
				disty = math.abs(sprites[i]["y"] - (marioY+dy))
				if distx <= 8 and disty <= 8 then
					inputs[#inputs] = -1
				end
			end

			for i = 1,#extended do
				distx = math.abs(extended[i]["x"] - (marioX+XShifted))
				disty = math.abs(extended[i]["y"] - (marioY+dy))
				if distx < 8 and disty < 8 then
					inputs[#inputs] = -1
				end
			end
		end
	end

	inputs[#inputs+1] = 0 -- allocation (velocity, X-axis)
	Nyoom = memory.read_s8(0x7B) -- full walking is ~2.4 (full run is ~5.6)
	examine = Nyoom / 8.324 -- this affects score EVERY FRAME!!!
	Nyoom = math.ceil(math.max(examine, 0)) -- walking backwards is ignored for score purposes
	inputs[#inputs] = examine -- potentially used for biassing neural net :)

	inputs[#inputs+1] = 0 -- allocation (on the ground?)
	examine = memory.readbyte(0x13EF) -- 0x01 = touching / standing on the ground
	if examine == 1 then -- ignores touching sides (see below)
		inputs[#inputs] = 0 -- Zero means NOT on the ground
	else
		inputs[#inputs] = 1 -- any other value, assume jumping
	end

	inputs[#inputs+1] = 0 -- allocation (running into a wall?)
	examine = memory.readbyte(0x77) -- bitmap SxxMUDLR, "M" = in a block (middle)
	if examine == 5 then -- S is for "due to scrolling"
		inputs[#inputs] = 1 -- Solid block to the right, AND solid ground (can't go down)
	else
		inputs[#inputs] = 0 -- otherwise, no signal from this "special case" perceptron
	end

	-- Simplified powerups table O_O
	inputs[#inputs+1] = 0 -- allocation (tall)
	examine = memory.readbyte(0x19)
	-- some of these are mutually exclusive...
	if examine == 0 then -- tiny flag is #0
		inputs[#inputs] = 0 -- mario is NOT tall (blanked)
	elseif examine == 1 then -- regular "big" flag is #1
		inputs[#inputs] = 1 -- tall (mushroom variant)
	elseif examine == 2 then -- cape flag is #2
		inputs[#inputs] = 1 -- tall (cape variant)
	elseif examine == 3 then -- fire flag is #3
		inputs[#inputs] = 1 -- tall (cape variant)
	end
	return inputs
end

function sigmoid(x)
	return 2/(1+math.exp(-4.9*x))-1
end

function newInnovation()
	pool.innovation = pool.innovation + 1
	return pool.innovation
end

function newPool()
	local pool = {}
	pool.gatunek = {}
	pool.generation = 0
	pool.innovation = Outputs
	pool.currentGatunek = 1
	pool.currentCultivar = 1
	pool.EvaluatedFrames = 0
	pool.RealtimeFitness = 0
	pool.maxFitness = 0
	
	return pool
end

function newGatunek()
	local gatunek = {}
	gatunek.topFitness = 0
	gatunek.staleness = 0
	gatunek.cultivars = {}
	gatunek.averageFitness = 0
	
	return gatunek
end

function newCritter()
	local critter = {}
	critter.genes = {}
	critter.fitness = 0
	critter.adjustedFitness = 0
	critter.brain = {}
	critter.maxneuron = 0
	critter.mutationRates = {}
	critter.mutationRates["connections"] = MutateConnectionsChance
	critter.mutationRates["link"] = LinkMutationChance
	critter.mutationRates["bias"] = BiasMutationChance
	critter.mutationRates["node"] = NodeMutationChance
	critter.mutationRates["enable"] = EnableMutationChance
	critter.mutationRates["disable"] = DisableMutationChance
	critter.mutationRates["step"] = StepSize
	
	return critter
end

function copyHotness(billy)
	local cultivar2 = newCritter()
	for g=1,#billy.genes do
		table.insert(cultivar2.genes, copyGene(billy.genes[g]))
	end
	cultivar2.maxneuron = billy.maxneuron
	cultivar2.mutationRates["connections"] = billy.mutationRates["connections"]
	cultivar2.mutationRates["link"] = billy.mutationRates["link"]
	cultivar2.mutationRates["bias"] = billy.mutationRates["bias"]
	cultivar2.mutationRates["node"] = billy.mutationRates["node"]
	cultivar2.mutationRates["enable"] = billy.mutationRates["enable"]
	cultivar2.mutationRates["disable"] = billy.mutationRates["disable"]
	
	return cultivar2
end

function basicCritter()
	local gir = newCritter()
	local innovation = 1

	gir.maxneuron = Inputs
	mutate(gir) -- what does the G stand for?
	
	return gir -- I don't know O_O
end

function newGene()
	local gene = {}
	gene.into = 0
	gene.out = 0
	gene.weight = 0.0
	gene.enabled = true
	gene.innovation = 0
	
	return gene
end

function copyGene(gene)
	local gene2 = newGene()
	gene2.into = gene.into
	gene2.out = gene.out
	gene2.weight = gene.weight
	gene2.enabled = gene.enabled
	gene2.innovation = gene.innovation
	
	return gene2
end

function newNeuron()
	local neuron = {}
	neuron.incoming = {}
	neuron.value = 0.0
	
	return neuron
end

function generateMind(cultivar)
	local MeatyThinky = {}
	MeatyThinky.neurons = {}
	
	for i=1,Inputs do
		MeatyThinky.neurons[i] = newNeuron()
	end
	
	for o=1,Outputs do
		MeatyThinky.neurons[MaxNodes+o] = newNeuron()
	end
	
	table.sort(cultivar.genes, function (a,b)
		return (a.out < b.out)
	end)
	for i=1,#cultivar.genes do
		local gene = cultivar.genes[i]
		if gene.enabled then
			if MeatyThinky.neurons[gene.out] == nil then
				MeatyThinky.neurons[gene.out] = newNeuron()
			end
			local neuron = MeatyThinky.neurons[gene.out]
			table.insert(neuron.incoming, gene)
			if MeatyThinky.neurons[gene.into] == nil then
				MeatyThinky.neurons[gene.into] = newNeuron()
			end
		end
	end
	
	cultivar.brain = MeatyThinky -- NOT a meat brain O_O
end

function evaluateThoughts(network, inputs)
	table.insert(inputs, 1)
	if #inputs ~= Inputs then
		console.writeline("Incorrect number of neural network inputs.")
		return {}
	end
	
	for i=1,Inputs do
		network.neurons[i].value = inputs[i]
	end
	
	for _,neuron in pairs(network.neurons) do
		local istota = 0
		for j = 1,#neuron.incoming do
			local incoming = neuron.incoming[j]
			local other = network.neurons[incoming.into]
			istota = istota + incoming.weight * other.value
		end
		
		if #neuron.incoming > 0 then
			neuron.value = sigmoid(istota)
		end
	end
	
	local outputs = {}
	for o=1,Outputs do
		local button = "P1 " .. ButtonNames[o]
		if network.neurons[MaxNodes+o].value > 0 then
			outputs[button] = true
		else
			outputs[button] = false
		end
	end
	
	return outputs
end

function crossover(g1, g2)
	-- Make sure g1 is the higher fitness cultivar
	if g2.fitness > g1.fitness then
		tempg = g1
		g1 = g2
		g2 = tempg
	end

	local child = newCritter()
	
	local innovations2 = {}
	for i=1,#g2.genes do
		local gene = g2.genes[i]
		innovations2[gene.innovation] = gene
	end
	
	for i=1,#g1.genes do
		local gene1 = g1.genes[i]
		local gene2 = innovations2[gene1.innovation]
		if gene2 ~= nil and math.random(2) == 1 and gene2.enabled then
			table.insert(child.genes, copyGene(gene2))
		else
			table.insert(child.genes, copyGene(gene1))
		end
	end
	
	child.maxneuron = math.max(g1.maxneuron,g2.maxneuron)
	
	for mutation,rate in pairs(g1.mutationRates) do
		child.mutationRates[mutation] = rate
	end
	
	return child
end

function randomNeuron(genes, nonInput)
	local neurons = {}
	if not nonInput then
		for i=1,Inputs do
			neurons[i] = true
		end
	end
	for o=1,Outputs do
		neurons[MaxNodes+o] = true
	end
	for i=1,#genes do
		if (not nonInput) or genes[i].into > Inputs then
			neurons[genes[i].into] = true
		end
		if (not nonInput) or genes[i].out > Inputs then
			neurons[genes[i].out] = true
		end
	end

	local count = 0
	for _,_ in pairs(neurons) do
		count = count + 1
	end
	local n = math.random(1, count)
	
	for k,v in pairs(neurons) do
		n = n-1
		if n == 0 then
			return k
		end
	end
	
	return 0
end

function containsLink(genes, link)
	for i=1,#genes do
		local gene = genes[i]
		if gene.into == link.into and gene.out == link.out then
			return true
		end
	end
end

function pointMutate(cultivar)
	local step = cultivar.mutationRates["step"]
	
	for i=1,#cultivar.genes do
		local gene = cultivar.genes[i]
		if math.random() < PerturbChance then
			gene.weight = gene.weight + math.random() * step*2 - step
		else
			gene.weight = math.random()*4-2
		end
	end
end

function linkMutate(cultivar, forceBias)
	local neuron1 = randomNeuron(cultivar.genes, false)
	local neuron2 = randomNeuron(cultivar.genes, true)
	 
	local newLink = newGene()
	if neuron1 <= Inputs and neuron2 <= Inputs then
		--Both input nodes
		return
	end
	if neuron2 <= Inputs then
		-- Swap output and input
		local temp = neuron1
		neuron1 = neuron2
		neuron2 = temp
	end

	newLink.into = neuron1
	newLink.out = neuron2
	if forceBias then
		newLink.into = math.random((InputSize+1), Inputs) -- very perceptron O_O
	end
	
	if containsLink(cultivar.genes, newLink) then
		return
	end
	newLink.innovation = newInnovation()
	newLink.weight = math.random()*4-2
	
	table.insert(cultivar.genes, newLink)
end

function nodeMutate(cultivar)
	if #cultivar.genes == 0 then
		return
	end

	cultivar.maxneuron = cultivar.maxneuron + 1

	local gene = cultivar.genes[math.random(1,#cultivar.genes)]
	if not gene.enabled then
		return
	end
	gene.enabled = false
	
	local gene1 = copyGene(gene)
	gene1.out = cultivar.maxneuron
	gene1.weight = 1.0
	gene1.innovation = newInnovation()
	gene1.enabled = true
	table.insert(cultivar.genes, gene1)
	
	local gene2 = copyGene(gene)
	gene2.into = cultivar.maxneuron
	gene2.innovation = newInnovation()
	gene2.enabled = true
	table.insert(cultivar.genes, gene2)
end

function enableDisableMutate(cultivar, enable)
	local candidates = {}
	for _,gene in pairs(cultivar.genes) do
		if gene.enabled == not enable then
			table.insert(candidates, gene)
		end
	end
	
	if #candidates == 0 then
		return
	end
	
	local gene = candidates[math.random(1,#candidates)]
	gene.enabled = not gene.enabled
end

function mutate(cultivar)
	for mutation,rate in pairs(cultivar.mutationRates) do
		if math.random(1,2) == 1 then
			cultivar.mutationRates[mutation] = 0.95*rate
		else
			cultivar.mutationRates[mutation] = 1.05263*rate
		end
	end

	if math.random() < cultivar.mutationRates["connections"] then
		pointMutate(cultivar)
	end
	
	local p = cultivar.mutationRates["link"]
	while p > 0 do
		if math.random() < p then
			linkMutate(cultivar, false)
		end
		p = p - 1
	end

	p = cultivar.mutationRates["bias"]
	while p > 0 do
		if math.random() < p then
			linkMutate(cultivar, true)
		end
		p = p - 1
	end
	
	p = cultivar.mutationRates["node"]
	while p > 0 do
		if math.random() < p then
			nodeMutate(cultivar)
		end
		p = p - 1
	end

	p = cultivar.mutationRates["disable"] -- DIASBLE FIRST!!!
	while p > 0 do
		if math.random() < p then
			enableDisableMutate(cultivar, false)
		end
		p = p - 1
	end

	p = cultivar.mutationRates["enable"]
	while p > 0 do
		if math.random() < p then
			enableDisableMutate(cultivar, true)
		end
		p = p - 1
	end

end

function disjoint(genes1, genes2)
	local i1 = {}
	for i = 1,#genes1 do
		local gene = genes1[i]
		i1[gene.innovation] = true
	end

	local i2 = {}
	for i = 1,#genes2 do
		local gene = genes2[i]
		i2[gene.innovation] = true
	end
	
	local disjointGenes = 0
	for i = 1,#genes1 do
		local gene = genes1[i]
		if not i2[gene.innovation] then
			disjointGenes = disjointGenes+1
		end
	end
	
	for i = 1,#genes2 do
		local gene = genes2[i]
		if not i1[gene.innovation] then
			disjointGenes = disjointGenes+1
		end
	end
	
	local n = math.max(#genes1, #genes2)
	
	return disjointGenes / n
end

function weights(genes1, genes2)
	local i2 = {}
	for i = 1,#genes2 do
		local gene = genes2[i]
		i2[gene.innovation] = gene
	end

	local istota = 0
	local zgodny = 0
	for i = 1,#genes1 do
		local gene = genes1[i]
		if i2[gene.innovation] ~= nil then
			local gene2 = i2[gene.innovation]
			istota = istota + math.abs(gene.weight - gene2.weight)
			zgodny = zgodny + 1
		end
	end
	
	return istota / zgodny
end
	
function sameGatunek(cultivar1, cultivar2)
	local dd = DeltaDisjoint*disjoint(cultivar1.genes, cultivar2.genes)
	local dw = DeltaWeights*weights(cultivar1.genes, cultivar2.genes) 
	return dd + dw < DeltaThreshold
end

function calculateAverageFitness(gatunek)
	local gatunek_total = 0
	
	for particular_critter=1,#gatunek.cultivars do
		local cultivar = gatunek.cultivars[particular_critter]
		gatunek_total = gatunek_total + cultivar.fitness
	end
	
	gatunek.averageFitness = gatunek_total / #gatunek.cultivars
end

function totalAverageFitness()
	local total = 0
	for s = 1,#pool.gatunek do
		local gatunek = pool.gatunek[s]
		total = total + gatunek.averageFitness
	end

	return total
end

function cullGatunek()
	for s = 1,#pool.gatunek do
		local gatunek = pool.gatunek[s]
		
		table.sort(gatunek.cultivars, function (a,b)
			return (a.fitness > b.fitness)
		end)
		
		local remaining = math.max(math.ceil(0.5+(#gatunek.cultivars)*0.6614756), 1) -- never cull the last one
		while #gatunek.cultivars > remaining do
			table.remove(gatunek.cultivars)
		end
	end
end

function breedChild(stud)
	local child = {} -- The following abstract concepts are legit:
	local genetic_material = stud.cultivars[math.random(1, #stud.cultivars)]
	if math.random() < CrossoverChance then -- cloning is fast, but this is fun sometimes
		local allgatunek = pool.gatunek -- ONLY THE LIVING are on this canidates list O_O
		local anygatunek = allgatunek[math.random(1, #allgatunek)] -- reverse wild oat sowing
		blind_date = anygatunek.cultivars[math.random(1, #anygatunek.cultivars)]
		child = crossover(genetic_material, blind_date) -- romantic calculations are involved
	else
		attractive_cousin = stud.cultivars[math.random(1, #stud.cultivars)]
		child = copyHotness(attractive_cousin) -- CLONE THE HOTNESS!!!
	end
	
	mutate(child) -- one spark of life plskthx
	
	return child -- this child is now an adult O_O
end

function removeStaleGatunek()
	local survived = {}

	for s = 1,#pool.gatunek do
		local gatunek = pool.gatunek[s]
		table.sort(gatunek.cultivars, function (a,b)
			return (a.fitness > b.fitness)
		end)
		if gatunek.cultivars[1].fitness > gatunek.topFitness then
			gatunek.topFitness = gatunek.cultivars[1].fitness
			gatunek.staleness = 0
		else
			gatunek.staleness = gatunek.staleness + 1
		end
		if gatunek.staleness < StaleGatunek or gatunek.topFitness >= pool.maxFitness then
			table.insert(survived, gatunek)
		end
	end

	pool.gatunek = survived
end

function removeWeakGatunek()
	local survived = {}
	local s = 0

	local global_fitness = totalAverageFitness() / #pool.gatunek
	for s = 1,#pool.gatunek do
		local gatunek = pool.gatunek[s]
		breed = gatunek.averageFitness / global_fitness
		if breed >= 0.55 then
			table.insert(survived, gatunek)
		end
	end

	if next(survived) == nil then -- checking for empty table "the lua way" [tm]
		table.insert(survived, next(pool.gatunek)) -- uh... "this one lives" (but they're all rubbish)
	end

	pool.gatunek = survived
end


function addToGatunek(child)
	local foundGatunek = false
	for s=1,#pool.gatunek do
		local gatunek = pool.gatunek[s]
		if not foundGatunek and sameGatunek(child, gatunek.cultivars[1]) then
			table.insert(gatunek.cultivars, child)
			foundGatunek = true
		end
	end
	
	if not foundGatunek then
		local childGatunek = newGatunek()
		table.insert(childGatunek.cultivars, child)
		table.insert(pool.gatunek, childGatunek)
	end
end

function newGeneration()
	removeStaleGatunek() -- old generations die off over time
	cullGatunek() -- Make room for non-rubbish gatunek
	for s, gatunek in ipairs(pool.gatunek) do
		calculateAverageFitness(gatunek)
	end
	removeWeakGatunek() -- everbody dies
	cullGatunek() -- more death... I guess O_O
	for s, gatunek in ipairs(pool.gatunek) do -- (that last cull brought a few averages UP)
		local gatunek = pool.gatunek[s]
		calculateAverageFitness(gatunek)
	end	
	CurrentSwarm = #pool.gatunek -- Is anyone still alive?
	local Population_Control = CurrentSwarm + GenerationGain
	local Gain_Rate = math.log(Population_Control / GenerationGain) -- natural log
	local Target_gain = (GenerationGain / (0.618 + Gain_Rate)) - AntiGain -- Limiter
	SwarmLimit = math.ceil(CurrentSwarm + Target_gain) -- how many are allowed?
	local istota = totalAverageFitness()
	local children = {}

	for s, gatunek in ipairs(pool.gatunek) do
		global_fitness = istota / CurrentSwarm -- Just what's already been measured
		innov = math.sqrt(gatunek.averageFitness / global_fitness)
		threethreethree = math.exp(innov) / 3333 -- actually that's four threes
		fifthroot = threethreethree ^ (1 / 3) -- third root
		breed = math.floor(fifthroot * 1000) - 90
		if breed > 0 then -- "breeding tickets" for bad VS good genes
		gatunek.staleness = 0 -- stale implies BELOW average
			for i=1,breed do -- Make babies, based on the score
				if gatunek.averageFitness > 1 then -- for sanity
					table.insert(children, gatunek)
				end
			end
		end
	end
	if next(children) == nil then
		console.writeline("Stale generation")
		while #pool.gatunek < SwarmLimit do -- make sure there's enough
			basic = basicCritter()
			addToGatunek(basic)
		end
	else
		pool.generation = pool.generation + 1 -- NEW GENERATION COMPLETE!!!
		while #pool.gatunek < SwarmLimit do
			random_critter_chance = 1 / math.min(pool.generation, 1) -- dividing by zero is forbidden
			if math.random() < random_critter_chance then
				basic = basicCritter()
				addToGatunek(basic) -- this one is totally random
			end
			local gatunek = pool.gatunek[math.random(1, #pool.gatunek)]
			addToGatunek(breedChild(gatunek)) -- this one has good genes
		end
	end

	writeFile("backup." .. pool.generation .. "." .. forms.gettext(saveLoadFile))
end

function initializePool()
	pool = newPool()

	while #pool.gatunek < GenerationGain do -- Start out with "this many" [tm]
		basic = basicCritter()
		addToGatunek(basic)
	end
	CurrentSwarm = #pool.gatunek -- be sure to record the size
	initializeRun()
end

function clearJoypad()
	controller = {}
	for b = 1,#ButtonNames do
		controller["P1 " .. ButtonNames[b]] = false
	end
	joypad.set(controller)
end

function initializeRun()
	savestate.load(Filename);
	rightmost = 0
	pool.EvaluatedFrames = 0
	pool.RealtimeFitness = 0
	Nyoom = 0 -- motion starts at zero
	NyoomCumulator = 0 -- accumulated speed bonus also starts at zero
	timeout = TimeoutConstant
	clearJoypad()
	
	local gatunek = pool.gatunek[pool.currentGatunek]
	local cultivar = gatunek.cultivars[pool.currentCultivar]
	generateMind(cultivar)
	evaluateCurrent()
end

function evaluateCurrent()
	local gatunek = pool.gatunek[pool.currentGatunek]
	local cultivar = gatunek.cultivars[pool.currentCultivar]

	inputs = getInputs()
	controller = evaluateThoughts(cultivar.brain, inputs)
	
	if controller["P1 Left"] and controller["P1 Right"] then
		controller["P1 Left"] = false
		controller["P1 Right"] = false
	end
	if controller["P1 Up"] and controller["P1 Down"] then
		controller["P1 Up"] = false
		controller["P1 Down"] = false
	end

	joypad.set(controller)
end

if pool == nil then
	initializePool()
end


function nextCritter()
	pool.currentCultivar = pool.currentCultivar + 1
	if pool.currentCultivar > #pool.gatunek[pool.currentGatunek].cultivars then
		pool.currentCultivar = 1
		pool.currentGatunek = pool.currentGatunek+1
		if pool.currentGatunek > #pool.gatunek then
			newGeneration()
			pool.currentGatunek = 1
		end
	end
end

function fitnessAlreadyMeasured()
	local gatunek = pool.gatunek[pool.currentGatunek]
	local cultivar = gatunek.cultivars[pool.currentCultivar]
	
	return cultivar.fitness ~= 0
end

function displayCritter(cultivar)
	local network = cultivar.brain -- artificial neural network
	local cells = {}
	local skiplast = 0
	local blacken = 0
	local i = 1
	local cell = {}
	for dy=-BoxRadius,BoxRadius do
		for dx=-BoxRadius,BoxRadius do
			cell = {}
			cell.x = 50+5*dx
			cell.y = 70+5*dy
			cell.value = network.neurons[i].value
			cells[i] = cell
			i = i + 1
		end
	end

		cell = {} -- Velocity vector (X-axis)
		cell.x = 50+5*network.neurons[i].value
		cell.y = 70+5*(BoxRadius+1)
		blacken = math.abs(network.neurons[i].value / 5)
		if blacken < 0.1 then
			blacken = -1
		end
		cell.value = blacken -- zero handler for display
		cells[i] = cell
		i = i + 1

	for skiplast =i,(Inputs-1) do -- Automagically knows how many more perceptron!!!
		cell = {}
		cell.x = 50+5*(BoxRadius+1)
		cell.y = 70+5*(skiplast-(i+BoxRadius))
		cell.value = network.neurons[skiplast].value
		cells[skiplast] = cell
	
	end
	local biasCell = {}
	biasCell.x = 80
	biasCell.y = 110
	biasCell.value = network.neurons[Inputs].value
	cells[Inputs] = biasCell
	
	for o = 1,Outputs do
		cell = {}
		cell.x = 200
		cell.y = 45 + 9 * o
		cell.value = network.neurons[MaxNodes + o].value
		cells[MaxNodes+o] = cell
		local color
		if cell.value > 0 then
			color = 0xFF452AFF
		else
			color = 0xFFFFFFFF
		end
		gui.drawText(203, 39+9*o, ButtonNames[o], color, 9)
	end
	
	for n,neuron in pairs(network.neurons) do
		cell = {}
		if n > Inputs and n <= MaxNodes then
			cell.x = 140
			cell.y = 40
			cell.value = neuron.value
			cells[n] = cell
		end
	end
	
	for n=1,4 do
		for _,gene in pairs(cultivar.genes) do
			if gene.enabled then
				local c1 = cells[gene.into]
				local c2 = cells[gene.out]
				if gene.into > Inputs and gene.into <= MaxNodes then
					c1.x = 0.75*c1.x + 0.25*c2.x
					if c1.x >= c2.x then
						c1.x = c1.x - 40
					end
					if c1.x < 90 then
						c1.x = 90
					end
					
					if c1.x > 220 then
						c1.x = 220
					end
					c1.y = 0.75*c1.y + 0.25*c2.y
					
				end
				if gene.out > Inputs and gene.out <= MaxNodes then
					c2.x = 0.25*c1.x + 0.75*c2.x
					if c1.x >= c2.x then
						c2.x = c2.x + 40
					end
					if c2.x < 90 then
						c2.x = 90
					end
					if c2.x > 220 then
						c2.x = 220
					end
					c2.y = 0.25*c1.y + 0.75*c2.y
				end
			end
		end
	end
	
	gui.drawBox(50-BoxRadius*5-3,70-BoxRadius*5-3,50+BoxRadius*5+2,70+BoxRadius*5+2,0xFFFFFFFF, 0x80808080)
	for n,cell in pairs(cells) do
		if n > Inputs or cell.value ~= 0 then
			local color = math.floor((cell.value+1)/2*256)
			if color > 255 then color = 255 end
			if color < 0 then color = 0 end
			local opacity = 0xCC000000
			if cell.value == 0 then
				opacity = 0x77000000
			end
			color = opacity + color*0x10000 + color*0x100 + color
			gui.drawBox(cell.x-1,cell.y-1,cell.x+1,cell.y+1,opacity,color)
		end
	end
	for _,gene in pairs(cultivar.genes) do
		if gene.enabled then
			local c1 = cells[gene.into]
			local c2 = cells[gene.out]
			local opacity = 0xCC000000
			if c1.value == 0 then
				opacity = 0x77000000
			end
			
			local color = 0x80-math.floor(math.abs(sigmoid(gene.weight))*0x80)
			if gene.weight > 0 then 
				color = opacity + 0x8000 + 0x10000*color
			else
				color = opacity + 0x800000 + 0x100*color
			end
			gui.drawLine(c1.x+1, c1.y, c2.x-1, c2.y, color)
		end
	end
	
	gui.drawBox(49-Mario_Map_Offset,71,51-Mario_Map_Offset,78,0x00000000,0x80FF0000)
	
	if forms.ischecked(showMutationRates) then
		local pos = 100
		for mutation,rate in pairs(cultivar.mutationRates) do
			gui.drawText(100, pos, mutation .. ": " .. rate, 0xFFFFFFFF, 10)
			pos = pos + 8
		end
	end
end

function writeFile(filename)
        local file = io.open(filename, "w")
	file:write(pool.generation .. "\n")
	file:write(pool.maxFitness .. "\n")
	file:write(#pool.gatunek .. "\n")
        for n,gatunek in pairs(pool.gatunek) do
		file:write(gatunek.topFitness .. "\n")
		file:write(gatunek.staleness .. "\n")
		file:write(#gatunek.cultivars .. "\n")
		for m,cultivar in pairs(gatunek.cultivars) do
			file:write(cultivar.fitness .. "\n")
			file:write(cultivar.maxneuron .. "\n")
			for mutation,rate in pairs(cultivar.mutationRates) do
				file:write(mutation .. "\n")
				file:write(rate .. "\n")
			end
			file:write("done\n")
			
			file:write(#cultivar.genes .. "\n")
			for l,gene in pairs(cultivar.genes) do
				file:write(gene.into .. " ")
				file:write(gene.out .. " ")
				file:write(gene.weight .. " ")
				file:write(gene.innovation .. " ")
				if(gene.enabled) then
					file:write("1\n")
				else
					file:write("0\n")
				end
			end
		end
        end
        file:close()
end

function savePool()
	local filename = forms.gettext(saveLoadFile)
	writeFile(filename)
end

function loadFile(filename)
        local file = io.open(filename, "r")
	pool = newPool()
	pool.generation = file:read("*number")
	pool.maxFitness = file:read("*number")
	forms.settext(maxFitnessLabel, "Max Fitness: " .. math.floor(pool.maxFitness))
        local numGatunek = file:read("*number")
        for s=1,numGatunek do
		local gatunek = newGatunek()
		table.insert(pool.gatunek, gatunek)
		gatunek.topFitness = file:read("*number")
		gatunek.staleness = file:read("*number")
		local numCritters = file:read("*number")
		for g=1,numCritters do
			local cultivar = newCritter()
			table.insert(gatunek.cultivars, cultivar)
			cultivar.fitness = file:read("*number")
			cultivar.maxneuron = file:read("*number")
			local line = file:read("*line")
			while line ~= "done" do
				cultivar.mutationRates[line] = file:read("*number")
				line = file:read("*line")
			end
			local numGenes = file:read("*number")
			for n=1,numGenes do
				local gene = newGene()
				table.insert(cultivar.genes, gene)
				local enabled
				gene.into, gene.out, gene.weight, gene.innovation, enabled = file:read("*number", "*number", "*number", "*number", "*number")
				if enabled == 0 then
					gene.enabled = false
				else
					gene.enabled = true
				end
				
			end
		end
	end
        file:close()
	
	while fitnessAlreadyMeasured() do
		nextCritter()
	end
	initializeRun()
end
 
function loadPool()
	local filename = forms.gettext(saveLoadFile)
	loadFile(filename)
end

function playTop()
	local maxfitness = 0
	local maxs, maxg
	for s,gatunek in pairs(pool.gatunek) do
		for g,cultivar in pairs(gatunek.cultivars) do
			if cultivar.fitness > maxfitness then
				maxfitness = cultivar.fitness
				maxs = s
				maxg = g
			end
		end
	end
	
	pool.currentGatunek = maxs
	pool.currentCultivar = maxg
	pool.maxFitness = maxfitness
	forms.settext(maxFitnessLabel, "Max Fitness: " .. math.floor(pool.maxFitness))
	initializeRun()
	return
end

function onExit()
	forms.destroy(form)
end

writeFile("temp.pool")

event.onexit(onExit)

form = forms.newform(200, 260, "Fitness")
maxFitnessLabel = forms.label(form, "Max Fitness: " .. math.floor(pool.maxFitness), 5, 8)
showNetwork = forms.checkbox(form, "Show Map", 5, 30)
showMutationRates = forms.checkbox(form, "Show M-Rates", 5, 52)
restartButton = forms.button(form, "Restart", initializePool, 5, 77)
saveButton = forms.button(form, "Save", savePool, 5, 102)
loadButton = forms.button(form, "Load", loadPool, 80, 102)
saveLoadFile = forms.textbox(form, Filename .. ".pool", 170, 25, nil, 5, 148)
saveLoadLabel = forms.label(form, "Save/Load:", 5, 129)
playTopButton = forms.button(form, "Play Top", playTop, 5, 170)
showBanner = forms.checkbox(form, "Show Banner", 5, 190)

client.speedmode(400) -- GO FASTER!!!

while true do
	local backgroundColor = 0xB7B54494
	if forms.ischecked(showBanner) then
		gui.drawBox(0, 0, 300, 26, backgroundColor, backgroundColor)
	end

	local gatunek = pool.gatunek[pool.currentGatunek]
	local cultivar = gatunek.cultivars[pool.currentCultivar]
	
	if forms.ischecked(showNetwork) then
		displayCritter(cultivar)
	end

	evaluateCurrent() -- EVERY FRAME!!!

	joypad.set(controller)

	getPositions()

	-- This lets us know if mario is still alive and game is active :)
	StatusRegister = memory.readbyte(0x100) + memory.readbyte(0x9D)

	if memory.read_s16_le(0x94) > rightmost then
		rightmost = memory.read_s16_le(0x94) -- helps detect end of level
		timeout = TimeoutConstant
	end
	if StatusRegister == 0x14 then -- mario's brain is active
		pool.EvaluatedFrames = pool.EvaluatedFrames + 1
		NyoomCumulator = NyoomCumulator + Nyoom -- Speed is very important :)
	end

	timeout = timeout - 1

	local timeoutBonus = math.floor(pool.EvaluatedFrames / 10.472)
	if timeoutBonus < 1 then
		timeoutBonus = 1 -- sanitized
	end

	local score = memory.read_u24_le(0x0F34) -- literal in-game score
	pool.RealtimeFitness = 222 + score + NyoomCumulator - math.ceil(pool.EvaluatedFrames * 2.2925) -- game score and velocity :D

	if (timeout + timeoutBonus) < 0 then
		fitness = pool.RealtimeFitness -- local (non-realtime) fitness
		if rightmost > 4816 and memory.readbyte(0x13D6) < 0x80 then -- 4816: yoshi island 1 & 2 
			fitness = fitness + 500 -- VICTORY!!! (non-realtime) bonus
		end
		if fitness < 1 then -- zero is a "magic number" to indicate untested status
			fitness = 1
		end
		cultivar.fitness = fitness
		
		if fitness > pool.maxFitness then
			pool.maxFitness = fitness
			forms.settext(maxFitnessLabel, "Max Fitness: " .. math.floor(pool.maxFitness))
			writeFile("backup." .. pool.generation .. "." .. forms.gettext(saveLoadFile))
		end
		
		console.writeline("Gen " .. pool.generation .. " gatunek " .. pool.currentGatunek .. " cultivar " .. pool.currentCultivar .. " fitness: " .. fitness)
		pool.currentGatunek = 1
		pool.currentCultivar = 1
		while fitnessAlreadyMeasured() do
			nextCritter()
		end
		initializeRun()
	end

	if forms.ischecked(showBanner) then
		gui.drawText(0, 0, "[" .. pool.generation .. "] Gatunek #" .. pool.currentGatunek .. " ~> Cultivar #" .. pool.currentCultivar, 0xFFFFFFFF, 11)
		gui.drawText(0, 12, "Fitness: " .. pool.RealtimeFitness, 0xFFFFFFFF, 11)
		gui.drawText(100, 12, "Max Fitness: " .. math.floor(pool.maxFitness), 0xFFFFFFFF, 11)
	end
		

	emu.frameadvance();
end